<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IAgent - Asistente de Voz</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 500px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .status.disconnected {
            background-color: #ffebee;
            color: #c62828;
            border: 2px solid #ffcdd2;
        }
        
        .status.connecting {
            background-color: #fff3e0;
            color: #ef6c00;
            border: 2px solid #ffcc02;
        }
        
        .status.connected {
            background-color: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #a5d6a7;
        }
        
        .connect-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 20px 0;
            min-width: 200px;
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        
        .connect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-status {
            margin: 30px 0;
            display: none;
            text-align: center;
        }
        
        .audio-status.show {
            display: block;
        }
        
        .audio-indicator {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 15px 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .audio-icon {
            font-size: 1.3em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .logs {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-info {
            color: #1976d2;
        }
        
        .log-success {
            color: #388e3c;
        }
        
        .log-error {
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ¤– IAgent</h1>
        <p>Asistente de Voz Inteligente</p>
        
        <div id="status" class="status disconnected">
            Desconectado
        </div>
        
        <button id="connectBtn" class="connect-btn">
            Conectar
        </button>
        
        <div id="audioStatus" class="audio-status">
            <div class="audio-indicator">
                <span class="audio-icon">ðŸŽ§</span>
                <span>Audio conectado</span>
            </div>
            <audio id="remoteAudio" style="display: none;" autoplay></audio>
        </div>
        
        <div class="logs">
            <div id="logs"></div>
        </div>
    </div>

    <script>
        // ConfiguraciÃ³n
        const API_GATEWAY_URL = 'http://localhost:8000';
        const SPEECH_SERVICE_ENDPOINT = '/api/v1/speech';
        
        // Referencias a elementos DOM
        const statusElement = document.getElementById('status');
        const connectBtn = document.getElementById('connectBtn');
        const audioStatus = document.getElementById('audioStatus');
        const remoteAudio = document.getElementById('remoteAudio');
        const logsElement = document.getElementById('logs');
        
        // Estado de la aplicaciÃ³n
        let isConnected = false;
        let peerConnection = null;
        
        // ID de la entrevista (hardcodeado para pruebas)
        const interviewId = 1;
        
        // FunciÃ³n para agregar logs
        function addLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsElement.appendChild(logEntry);
            logsElement.scrollTop = logsElement.scrollHeight;
        }
        
        // FunciÃ³n para actualizar el estado
        function updateStatus(status, message) {
            statusElement.className = `status ${status}`;
            statusElement.textContent = message;
            addLog(`Estado: ${message}`, status === 'connected' ? 'success' : 'info');
        }
        
        // FunciÃ³n para crear conexiÃ³n WebRTC
        async function createWebRTCConnection() {
            const connectionStartTime = performance.now();
            try {
                addLog('ðŸš€ Iniciando conexiÃ³n WebRTC...');
                // ConfiguraciÃ³n de WebRTC
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                };
                
                // Crear peer connection
                const pcCreateStart = performance.now();
                peerConnection = new RTCPeerConnection(configuration);
                addLog(`â±ï¸ Peer connection creada en ${(performance.now() - pcCreateStart).toFixed(1)}ms`);
                
                // Manejar stream remoto
                peerConnection.ontrack = (event) => {
                    addLog('Stream de audio recibido', 'success');
                    remoteAudio.srcObject = event.streams[0];
                    audioStatus.classList.add('show');
                };
                
                // Manejar cambios de estado de conexiÃ³n
                peerConnection.onconnectionstatechange = () => {
                    addLog(`Estado WebRTC: ${peerConnection.connectionState}`);
                    
                    if (peerConnection.connectionState === 'connected') {
                        updateStatus('connected', 'Conectado');
                        connectBtn.textContent = 'Desconectar';
                        isConnected = true;
                    } else if (peerConnection.connectionState === 'disconnected' || 
                              peerConnection.connectionState === 'failed') {
                        handleDisconnection();
                    }
                };
                
                // Obtener acceso al micrÃ³fono
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, stream);
                });
                
                addLog('MicrÃ³fono configurado', 'success');
                
                // Crear oferta
                const offerStart = performance.now();
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                addLog(`â±ï¸ Oferta SDP creada en ${(performance.now() - offerStart).toFixed(1)}ms`);
                
                // Esperar a que se complete la recolecciÃ³n de candidatos ICE
                const iceStart = performance.now();
                await waitForIceGatheringComplete();
                addLog(`â±ï¸ Candidatos ICE recolectados en ${(performance.now() - iceStart).toFixed(1)}ms`);              // Enviar oferta al speech service a travÃ©s del API Gateway
                const serverStart = performance.now();
                const response = await fetch(`${API_GATEWAY_URL}${SPEECH_SERVICE_ENDPOINT}/offer`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        sdp: offer.sdp,
                        type: offer.type,
                        interview_id: interviewId
                    })
                });
                addLog(`â±ï¸ Respuesta del servidor recibida en ${(performance.now() - serverStart).toFixed(1)}ms`);
                
                if (!response.ok) {
                    throw new Error(`Error del servidor: ${response.status}`);
                }
                
                const answer = await response.json();
                addLog('Respuesta recibida del servidor', 'success');
                
                // Establecer descripciÃ³n remota
                await peerConnection.setRemoteDescription({
                    type: answer.type,
                    sdp: answer.sdp
                });
                
                const totalConnectionTime = performance.now() - connectionStartTime;
                addLog('âœ… ConexiÃ³n WebRTC establecida exitosamente', 'success');
                addLog(`â±ï¸ Tiempo total de conexiÃ³n: ${totalConnectionTime.toFixed(1)}ms`);
                
            } catch (error) {
                addLog(`Error en conexiÃ³n: ${error.message}`, 'error');
                handleDisconnection();
            }
        }
        
        // FunciÃ³n para esperar la recolecciÃ³n completa de candidatos ICE con timeout optimizado
        function waitForIceGatheringComplete() {
            return new Promise((resolve) => {
                if (peerConnection.iceGatheringState === 'complete') {
                    addLog('Candidatos ICE ya recolectados');
                    resolve();
                } else {
                    let timeout;
                    const onStateChange = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            addLog('RecolecciÃ³n de candidatos ICE completada');
                            resolve();
                        }
                    };
                    
                    peerConnection.addEventListener('icegatheringstatechange', onStateChange);
                    
                    // Timeout agresivo de 3 segundos para evitar esperas excesivas
                    timeout = setTimeout(() => {
                        peerConnection.removeEventListener('icegatheringstatechange', onStateChange);
                        addLog('Timeout en recolecciÃ³n ICE - continuando con candidatos disponibles', 'warning');
                        resolve();
                    }, 3000);
                }
            });
        }
        
        // FunciÃ³n para manejar desconexiÃ³n
        function handleDisconnection() {
            isConnected = false;
            updateStatus('disconnected', 'Desconectado');
            connectBtn.textContent = 'Conectar';
            connectBtn.disabled = false;
            audioStatus.classList.remove('show');
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            addLog('Desconectado del servicio', 'info');
        }
        
        // FunciÃ³n para conectar/desconectar
        async function toggleConnection() {
            if (isConnected) {
                // Desconectar
                handleDisconnection();
            } else {
                // Conectar
                connectBtn.disabled = true;
                updateStatus('connecting', 'Conectando...');
                connectBtn.textContent = 'Conectando...';
                
                try {
                    await createWebRTCConnection();
                } catch (error) {
                    addLog(`Error de conexiÃ³n: ${error.message}`, 'error');
                    handleDisconnection();
                }
            }
        }
        
        // Event listeners
        connectBtn.addEventListener('click', toggleConnection);
        
        // InicializaciÃ³n
        addLog('AplicaciÃ³n iniciada');
        addLog(`API Gateway: ${API_GATEWAY_URL}`);
        
        // Iniciar conexiÃ³n automÃ¡ticamente
        setTimeout(() => {
            addLog('Iniciando conexiÃ³n automÃ¡tica...');
            toggleConnection();
        }, 1000);
    </script>
</body>
</html>